<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="./css/main.css" rel="stylesheet" >
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/styles/default.min.css">
  <link rel="stylesheet" href="./css/splitting.css" />
  <script src="./js/splitting.js"></script>
  <meta charset="utf-8"  />
  <style id="injected-keyframes-style"></style>
  <title>Kapsas</title>
</head>
<body>
  <div>
    <!-- Setting autocomplete off on input tags makes the values reset on soft refresh in FF --> 
    <form autocomplete="off" class="directChildrenInheritMarginTop" style="padding: 8px; background-color: #f5f5d4; text-align: center;">

      <div class="directChildrenInheritMarginTop collapsable-el-settings" style="margin-top: 4px;">
        <p>Settings</p>
        <style id="animation-settings" contenteditable="" class="font-lucida-console css-contenteditable-wrapper collapsable-el-settings" style="display: block; text-align: left; white-space: pre;"></style>
  
        
        <div class="center">
          <label for="input-text-textarea">Text</label>
          <div contenteditable name="input-text" class="css-contenteditable-wrapper" style="overflow-wrap: break-word; font-size: 40px; font-family: var(--font-uploaded);">
            <div id="input-text-textarea"></div>
          </div>
        </div>

        <div class="center" style="padding: 8px 0;">
          <p>Keyframes</p>
          <span>
            <a title="Animatable CSS properties" tabindex="-1" target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_animated_properties">
              <img style="color: black;" src="svg/question-circle-solid.svg" alt="question-circle-solid.svg" height="16px"></img>
            </a>
          </span>
          <div class="css-contenteditable-wrapper">
            <div contenteditable name="input-text" spellcheck="false" class="input-keyframes-textinput" id="input-keyframes-textinput"></div>
            <pre id="input-keyframes-textoutput" aria-hidden="true"></pre>
          </div>
        </div>


        <div class="center">
          <button type="button" tabindex="0" style="width: 120px; height: 40px;" id="input-font-btn">
            <img src="svg/upload-solid.svg" alt="upload-solid.svg" height="16px">Upload font</img>
          </button>
        </div>

        <div>
          <button type="button" tabindex="0" style="width: 120px; height: 40px;" id="input-button-animation-state-toggle">State: running</button>
          <button type="button" tabindex="0" style="width: 120px; height: 40px;" id="btn-start">Start</button>
        </div>
      </div>
      <div style="margin-top: 8px;">
        <img id="settings-collapse" data-state="expanded" style="color: black;" src="svg/chevron-up-solid.svg" alt="chevron-up-solid.svg" height="16px"/>
      </div>
    </form>

    <div class="font-uploaded set-keyframes-target" id="input-to-output-text-render" style="margin: 40px 0; text-align: center;">
        <div data-splitting>
          Content will be rendered here
        </div>
    </div>
  </div>
</div>
</body>
</html>

<script type="module">

  import hljs from 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/es/highlight.min.js';

  main();

  function main() {
    SetCssValues();
    SetHtmlValues();
    HandleEvents();
  }

  function HandleEvents() {
    KeyframeChangeEvent();
    HandleAnimationStateEvent();
    HandleStartEvent();
    HandleFontFileUploadEvent();
    ContentEditableNoDivHackEvent();
    HandleCollapseExpand();
  }

  function HandleCollapseExpand() {
    let collapseClickEl = document.querySelector('#settings-collapse');
    collapseClickEl.addEventListener('click', (e) => {
      let toCollapseElements = document.querySelectorAll('.collapsable-el-settings');
      let isCollapse = collapseClickEl.dataset.state === 'expanded';
      collapseClickEl.dataset.state = isCollapse ? 'collapsed' : 'expanded';
      for (let i = 0; i < toCollapseElements.length; i++) {
        const element = toCollapseElements[i];
        element.style.display = isCollapse ? 'none' : 'block';
      }
      [collapseClickEl.src, collapseClickEl.alt] = isCollapse ? ['svg/chevron-down-solid.svg', "chevron-down-solid.svg"] : ['svg/chevron-up-solid.svg', "chevron-up-solid.svg"];
    });
  }

  function KeyframeChangeEvent() {
    let elementKeyframes = document.querySelector('#input-keyframes-textinput');
    elementKeyframes.addEventListener('input', (e) => ChangeKeyframes(null));
  }

  function ContentEditableNoDivHackEvent() {
    /* 
    Replaces default enter <div> to enter <br> for pressing enter inside contenteditable element.
    Line break element <br> is easier to manipulate to match the #input-keyframes-textinput and #input-keyframes-textoutput elements. 
    */

      document.addEventListener('keydown', event => {
      if (event.key === 'Enter' && event.target.id === "input-keyframes-textinput") {
        console.log("blocked");
        document.execCommand('insertLineBreak')
        event.preventDefault()
      }
    });

  }

  function GetDefaultKeyframesValue() {
    let text = `
@keyframes myAnimation {
0%, 100% {
  font-variation-settings: 'wght' 100;
  font-size: 100px;
  color: #0000FF;
}

60% {
  font-variation-settings: 'wght' 700;
  font-size: 200px;
  color: #FF0000;
}
`.replace(/\r?\n/, "");  // forward slash starts and ends regex expression
    return text;
  }

  function GetDefaultSettings() {
    let text = `
:root {
  --row-height: 200px;
  --animation-duration: 4000ms;
  --bg-color: #ffffff;
  --animation-delay: 0ms;  /* Experimental */
}
`.replace(/\r?\n/, "");  // forward slash starts and ends regex expression
    return text;
  }


  function SetHtmlValues() {
    // Set values annoying to set using html to html elements
    // Newline can be set in html using &#10; (the linefeed character literal), but using \n or string templates is more elegant
    let elementInputText = document.querySelector("#input-text-textarea");
    elementInputText.innerHTML = 'regular<br>oxygen<br>ltLY';
    let elementKeyframes = document.querySelector('#input-keyframes-textinput');
    elementKeyframes.innerHTML = GetDefaultKeyframesValue();
    let elementKeyframesHighlighting = document.querySelector('#input-keyframes-textoutput');
    elementKeyframesHighlighting.innerHTML = hljs.highlight(elementKeyframes.innerHTML, {language: 'css'}).value;
    let elementSettingsInput = document.querySelector('#animation-settings');
    elementSettingsInput.innerHTML = GetDefaultSettings();
  }

  function SetCssValues() {
    ChangeKeyframes(GetDefaultKeyframesValue());
    
  }


  function PutTextIntoRender() {
    let elementInputText = document.querySelector("#input-text-textarea");
    let rows = elementInputText.innerHTML.split(/<br>/);
    let outputAreaBuilder = "";
    rows.forEach(row => {
      outputAreaBuilder += `<div class="adjustableHeight">${row}</div>`;
    });
    let outputArea = document.querySelector("#input-to-output-text-render");
    outputArea.innerHTML = `<div data-splitting>${outputAreaBuilder}<\div>`;
  }

  function HandleStartEvent() {
    let runBtn = document.querySelector("#btn-start");
    runBtn.addEventListener('click', (e) => {
      PutTextIntoRender()
      Splitting();
    })
  }

  function ChangeKeyframes(text = null) {
    if (text === null) {
      let elementKeyframes = document.querySelector('#input-keyframes-textinput');
      text = elementKeyframes.innerHTML.replaceAll("<br>", "\n");
    }

    document.querySelector('#injected-keyframes-style').innerHTML = text;
    let elementKeyframesHighlighting = document.querySelector('#input-keyframes-textoutput');
    elementKeyframesHighlighting.innerHTML = hljs.highlight(text, {language: 'css'}).value;
  }

  function HandleAnimationStateEvent() {
    let root = document.documentElement;
    root.style.setProperty('--animation-play-state', `running`)
    const toggle = document.getElementById('input-button-animation-state-toggle');
    toggle.addEventListener('click', () => {
      let newState = root.style.getPropertyValue('--animation-play-state') === 'running' ? 'paused' : 'running';
      root.style.setProperty('--animation-play-state', newState); 
      toggle.innerHTML = 'State: ' + newState;
    });
  }

  function HandleFontFileUploadEvent() {
    let reader = new FileReader();
    reader.onload = function(event) {
        let file = event.target.result;
        // document.head.append('<style type="text/css">@font-face { font-family:"MYFONT2"; src: url("'+file+'"); }</style>');
        SetFont(file)
    }
    let startReadingFile = (thisElement) => {
      let inputFile = thisElement.files[0];
      reader.readAsDataURL(inputFile);
    }
    let input = document.createElement('input');
    input.type = 'file';
    input.accept = '.ttf, .woff, .woff2';
    document.querySelector('#input-font-btn').addEventListener("click", () =>  {
      input.click();
    });
    input.addEventListener("change", () => startReadingFile(input));

  }

  function SetFont(fontFile) {
    let newFontName = 'UploadedFont';
    let font = new FontFace(newFontName, `url(${fontFile})`);
    font.load().then(function(loaded_face) {
      document.fonts.add(loaded_face);
      document.documentElement.style.setProperty('--font-uploaded', `"${newFontName}"`)
    }).catch(function(error) {
      throw Error(error);
    });
  }

</script>